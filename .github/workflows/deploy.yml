name: Deploy to VPS

on:
  push:
    branches:
      - main  # Change to your deployment branch
  workflow_dispatch:  # Allows manual triggering

env:
  REPO_NAME: ${{ github.event.repository.name }}
  BRANCH_NAME: ${{ github.ref_name }}
  IMAGE_NAME: ${{ github.event.repository.name }}-${{ github.ref_name }}
  CONTAINER_NAME: ${{ github.event.repository.name }}-${{ github.ref_name }}-container

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create .env file from secrets
        run: |
          echo "${{ secrets.VPS_ENV }}" > .env

      - name: Build Docker image
        run: |
          docker build -t ${{ env.IMAGE_NAME }}:${{ github.sha }} .

      - name: Save Docker image to tar
        run: |
          docker save ${{ env.IMAGE_NAME }}:${{ github.sha }} | gzip > docker-image.tar.gz

      - name: Copy Docker image to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_IP }}
          username: ${{ secrets.VPS_HOST }}
          key: ${{ secrets.VPS_KEY }}
          port: ${{ secrets.VPS_SSH_PORT }}
          source: "docker-image.tar.gz"
          target: "/tmp"

      - name: Copy .env to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_IP }}
          username: ${{ secrets.VPS_HOST }}
          key: ${{ secrets.VPS_KEY }}
          port: ${{ secrets.VPS_SSH_PORT }}
          source: ".env"
          target: "/tmp"

      - name: Deploy on VPS with Zero Downtime
        uses: appleboy/ssh-action@v1.0.3
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          APP_PORT: ${{ secrets.VPS_PORT }}
          SSH_PORT: ${{ secrets.VPS_SSH_PORT }}
          COMMIT_SHA: ${{ github.sha }}
        with:
          host: ${{ secrets.VPS_IP }}
          username: ${{ secrets.VPS_HOST }}
          key: ${{ secrets.VPS_KEY }}
          port: ${{ secrets.VPS_SSH_PORT }}
          envs: IMAGE_NAME,CONTAINER_NAME,APP_PORT,COMMIT_SHA
          script: |
            # Load the Docker image
            docker load < /tmp/docker-image.tar.gz
            
            # Define container names
            NEW_CONTAINER="${CONTAINER_NAME}-new"
            OLD_CONTAINER="${CONTAINER_NAME}"
            
            # Start new container on temporary port
            echo "Starting new container..."
            docker run -d \
              --name $NEW_CONTAINER \
              -p 0:3000 \
              --env-file /tmp/.env \
              --restart unless-stopped \
              $IMAGE_NAME:$COMMIT_SHA
            
            # Wait for new container to be healthy
            echo "Waiting for new container to be ready..."
            sleep 5
            
            # Check if new container is running
            if ! docker ps | grep -q $NEW_CONTAINER; then
              echo "❌ New container failed to start"
              docker logs $NEW_CONTAINER
              docker rm -f $NEW_CONTAINER 2>/dev/null || true
              exit 1
            fi
            
            # Health check (try to connect to the app)
            TEMP_PORT=$(docker port $NEW_CONTAINER 3000 | cut -d: -f2)
            for i in {1..10}; do
              if curl -f http://localhost:$TEMP_PORT >/dev/null 2>&1; then
                echo "✅ Health check passed"
                break
              fi
              if [ $i -eq 10 ]; then
                echo "❌ Health check failed"
                docker logs $NEW_CONTAINER
                docker rm -f $NEW_CONTAINER 2>/dev/null || true
                exit 1
              fi
              echo "Waiting for app to be ready... ($i/10)"
              sleep 3
            done
            
            # Stop new container temporarily
            docker stop $NEW_CONTAINER
            
            # Stop and remove old container (this is the quick switchover)
            echo "Switching containers..."
            docker stop $OLD_CONTAINER 2>/dev/null || true
            docker rm $OLD_CONTAINER 2>/dev/null || true
            
            # Rename new container to production name and restart with correct port
            docker rename $NEW_CONTAINER $OLD_CONTAINER
            docker start $OLD_CONTAINER
            
            # Update port mapping by recreating with correct port
            docker stop $OLD_CONTAINER
            docker rm $OLD_CONTAINER
            docker run -d \
              --name $OLD_CONTAINER \
              -p $APP_PORT:3000 \
              --env-file /tmp/.env \
              --restart unless-stopped \
              $IMAGE_NAME:$COMMIT_SHA
            
            # Final verification
            sleep 3
            if ! docker ps | grep -q $OLD_CONTAINER; then
              echo "❌ Final container failed to start"
              exit 1
            fi
            
            # Remove old images for this app (keep last 3)
            docker images | grep "^$IMAGE_NAME" | tail -n +4 | awk '{print $3}' | xargs -r docker rmi 2>/dev/null || true
            
            # Clean up
            rm /tmp/docker-image.tar.gz
            rm /tmp/.env
            
            echo "✅ Deployment completed successfully"
            docker ps | grep $OLD_CONTAINER

      - name: Verify deployment
        uses: appleboy/ssh-action@v1.0.3
        env:
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
        with:
          host: ${{ secrets.VPS_IP }}
          username: ${{ secrets.VPS_HOST }}
          key: ${{ secrets.VPS_KEY }}
          port: ${{ secrets.VPS_SSH_PORT }}
          envs: CONTAINER_NAME
          script: |
            echo "Waiting for application to start..."
            sleep 5
            
            # Check if container is running
            if docker ps | grep -q $CONTAINER_NAME; then
              echo "✅ Container is running"
              docker logs --tail 20 $CONTAINER_NAME
            else
              echo "❌ Container failed to start"
              docker logs $CONTAINER_NAME
              exit 1
            fi
